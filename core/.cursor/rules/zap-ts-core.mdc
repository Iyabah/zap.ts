---
description: 
globs: 
alwaysApply: true
---
# Zap.ts Architecture & Conventions

These rules define the structural and development standards for any project based on the Zap.ts stack.

They exist to maintain consistency, reliability, and clarity across codebases.

## Project Structure

Organize all logic under the `src/` directory, using the following layout:

* `actions/` — Server actions (e.g., `update-user.action.ts`)
* `app/` — Next.js app routes (pages, layouts, metadata)
* `components/` — Reusable UI components
  * `ui/` — Low-level primitives
  * `common/` — Feature-specific blocks
* `data/` — Static values, constants (UPPERCASE)
* `db/` — Drizzle ORM schemas and DB logic
* `hooks/` — Custom React hooks (`use-*`)
* `lib/` — Shared utilities (API clients, helpers)
* `providers/` — React context providers
* `rpc/` — oRPC type-safe procedures
* `stores/` — Zustand stores for app state
* `types/` — Global types and Zod schemas

## Naming Conventions

Use file names that reflect function and context:

| Type            | Pattern       | Example                 |
| --------------- | ------------- | ----------------------- |
| Hook            | `use-*.ts`    | `use-user-profile.ts`   |
| Component       | `*.tsx`       | `user-card.tsx`         |
| Store           | `*.store.ts`  | `user.store.ts`         |
| Server Action   | `*.action.ts` | `update-user.action.ts` |
| DB Schema (SQL) | `*.sql.ts`    | `auth.sql.ts`           |
| Zod Schema      | `*.schema.ts` | `user.schema.ts`        |
| RPC Procedure   | `*.rpc.ts`    | `user.rpc.ts`           |
| Constants       | Uppercase     | `BASE_URL` in `data/`   |

## Type Safety

* TypeScript is mandatory.
* All input/output validation must use Zod (`src/types/*.schema.ts`).
* Prefer Zustand over React Context.
* RPC must be type-safe with oRPC.

## State Management

* Use Zustand (`src/stores/`) for local/global state.
* Middleware: Use `persist` where needed.
* Wrap access in custom hooks for clarity.

```ts
import { create } from "zustand";

type UserState = {
  name: string;
  setName: (name: string) => void;
};

export const useUserStore = create<UserState>((set) => ({
  name: "",
  setName: (name) => set({ name }),
}));
```

## Type-Safe API

* Define oRPC functions in `src/rpc/procedures/`.
* Register them in [router.ts](mdc:core/src/rpc/router.ts).
* Use SWR or custom hooks for fetching client-side.

```ts
import { useORPC } from "@/zap/stores/orpc.store";
import useSWR from "swr";

export const useUserProfile = () => {
  const orpc = useORPC();
  return useSWR(orpc.userProfile.key(), orpc.userProfile.queryOptions().queryFn);
};
```

## Authentication

* Use the Better Auth package.
* Place auth logic in [server.ts](mdc:core/src/zap/lib/auth/server.ts).
* Use server actions for login/session handling.

## Database

* Use Drizzle ORM with PostgreSQL.
* Define schemas in `src/db/schema/`.
* Re-export from [index.ts](mdc:core/src/db/schema/index.ts).

```ts
import { z } from "zod";

export const userSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1),
});
```

## Error Handling

* Use [Effect](mdc:https:/effect.website) for typed async flows and errors.
* Avoid try/catch; prefer declarative error modeling.

## Environment Variables

* Store secrets/config in `.env`.
* Prefix anything MCP-specific with `MCP_`.

## PWA / SEO / Analytics

* Configure all in [zap.config.ts](mdc:core/zap.config.ts).
* PWA manifest is generated from config.
* Use `next-sitemap` for automated SEO sitemap generation.

## AI/LLM Integration

* Use Vercel AI SDK for streaming responses.
* Store encrypted API keys in database.
* Support multiple providers (OpenAI, Mistral).
* Use type-safe settings management with RPC.

```ts
// AI Settings Management
const { isSaving, saveApiKey } = useAISettings();
await saveApiKey({ provider: "openai", model: "gpt-4o-mini", apiKey: "..." });

// Streaming AI Responses
const { messages, input, handleSubmit } = useChat({
  api: "/api/ai/chat",
});
```

## Push Notifications

* Use browser Push API with service workers.
* Store subscriptions in database with user associations.
* Implement VAPID key management.
* Use web-push library for server-side sending.

```ts
// Subscribe to notifications
const { subscribe } = usePushNotifications();
await subscribe();

// Send notification (server-side)
await webpush.sendNotification(subscription, JSON.stringify({
  title: "New message",
  body: "You have a new message"
}));
```

## Email System

* Use Resend for transactional emails.
* Create React email templates.
* Implement rate limiting and tracking.
* Use Effect for error handling.

```ts
// Send verification email
await sendVerificationEmail({
  subject: "Verify your email",
  recipients: ["user@example.com"],
  url: "https://app.com/verify?token=abc123"
});
```

## Dependencies

* Use correct versions and constraints from [package.json](mdc:core/package.json).
* Avoid implicit version upgrades unless explicitly updated.